---
title: coroutine-1
tags:
---

## 什么是协程
协程（Coroutine）是一种具有多个入口点的程序部件。协程可以在某个特定的位置暂停执行，然后从这个位置又恢复执行。在恢复执行时，它所有的局部变量都会得到保留，就像拥有自己的堆栈一样。所以协程具有线程的一些性质。但是，协程实际上又是在单线程中运行的，在“切换”时，不会产生线程context切换，也就不会有在使用多线程时的切换开销。
协程可以用在很多似乎需要多线程去处理的问题中，如经典的生产者与消费者问题。

## 为什么用协程
众所周知，使用多线程去处理问题时，最容易出问题的地方就是子线程访问共享变量。由于竞争，我们在子线程在访问共享变量时，都要加上非常复杂的锁。但是使用协程的时候，协程的切换是由编程者控制的，不存在竞争问题，因此不用担心复杂的线程之间共享变量的问题。使用协程还有一个好处就是可以像写同步代码一样进行异步操作。如以下代码：

  def coroutine():
      while True:
      # Do something
          yield some_value

  cor = coroutine()
  process(next(cor))
  process(next(cor))

假设`coroutine`是一个非常耗时的操作，

## Python对协程的支持
在2005年，Python 2.5实现了[PEP 342](https://www.python.org/dev/peps/pep-0342/)。即通过增强生成器（Generator）的方式变相地支持了协程。这样实现的初衷是因为Python的生成器与协程有很大程度上的相似。如可以通过`yield`暂停生成器的执行，并从生成器中返回一个值给调用函数。调用函数能通过迭代器的`next`方法，恢复生成器的执行，而且生成器的局部变量是仍然保留着的。这是不是很像我们前面介绍过的协程？
